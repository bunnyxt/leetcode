# 96. Unique Binary Search Trees

| 题目 | 难度 |
| ---- | ---- |
| [96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/) | Medium |

## 题意

给一个正整数`n`，返回共有多少种结构不同的二叉搜索树，其中的结点正好是由数字`1, 2, .... n`构成。

## 分析

一个简单的思路是，对于`1, 2, ..., n`这一串数字构造BST，必然要选择一个结点作为根结点，所有根结点构成的BST的个数加起来就是整体的BST个数。那么我们依次选择`1`、`2`到`n`作为跟结点，其左右部分作为左右子树构造BST，这样左右部分又是一个相同的子问题。

## 题解1

### 思路

官方解答的思路1。

首先声明两个函数，`G(n)`表示以`1, 2, ..., n`构成的BST个数，也就是题目要求的值。`F(i, n)`表示以`i`为跟结点对以`1, 2, ..., n`构成的BST个数，其中跟结点`1 <= i <= n`。

显然，根据分析，我们可以得到，`G(n) = \sum_{i=1}^n F(i, n)`。

同样，对于`F(i, n)`，我们也可以化为由左右两个子序列构成的BST的乘积，即`F(i, n) = G(i - 1) * G(n - i)`。

注意，虽然右半部分是`i+1, i+2, ..., i+(n-i)`，但是尤其构成的BST与`1, 2, ..., n-1`是一样的，所以同样可以用`G(n - 1)`。

这样，结合以上两个式子，就能得到，`G(n) = \sum_{i=1}^n G(i - 1) * G(n - i)`。

另外，初始状态，`G[0] = G[1] = 1`。

走到这里，就发现，这其实是个DP了。

### 代码

```python
class Solution:
    def numTrees(self, n: int) -> int:
        G = [0] * (n + 1)
        G[0], G[1] = 1, 1
        for i in range(2, n + 1):
            for j in range(1, i + 1):
                G[i] += G[j - 1] * G[i - j]
        return G[n]
```

### 说明

同思路。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n^2) | O(n) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 30ms | 14.3MB |
| 排名 | 59.47% | 46.78% |

## 题解2

### 思路

第二遍做这个题的时候自己想的，基本思路还是一样的，挑一个根节点，然后两边乘起来，叠加，写成递推式子就是`G(n) = \sum_{i=1}^n G(i - 1) * G(n - i)`这样。

其实做到这里，这就是个自顶向下的DP了，带mem cache。

### 代码

```python
class Solution:
    def numTrees(self, n: int) -> int:
        mem = { 0: 1 }
        def dfs(n):
            if n not in mem:
                total = 0
                for root in range(n):
                    total += dfs(root) * dfs(n - root - 1)
                mem[n] = total
            return mem[n]
        return dfs(n)
```

### 说明

同思路。记得初始化`mem = { 0: 1 }`。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n^2) | O(n) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 28ms | 14.4MB |
| 排名 | 88.20% | 15.18% |

## 总结

借助BST作为背景的数学推导DP题，官方答案写得很好。

第二遍做的时候自己想出来的方法，最后发现其实也还是个DP，自顶向下带mem cache，殊途同归。
