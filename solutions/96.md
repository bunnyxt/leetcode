# 96. Unique Binary Search Trees

| 题目 | 难度 |
| ---- | ---- |
| [96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/) | Medium |

## 题意

给一个正整数`n`，返回共有多少种结构不同的二叉搜索树，其中的结点正好是由数字`1, 2, .... n`构成。

## 分析

一个简单的思路是，对于`1, 2, ..., n`这一串数字构造BST，必然要选择一个结点作为根结点，所有根结点构成的BST的个数加起来就是整体的BST个数。那么我们依次选择`1`、`2`到`n`作为跟结点，其左右部分作为左右子树构造BST，这样左右部分又是一个相同的子问题。

## 题解1

### 思路

官方解答的思路1。

首先声明两个函数，`G(n)`表示以`1, 2, ..., n`构成的BST个数，也就是题目要求的值。`F(i, n)`表示以`i`为跟结点对以`1, 2, ..., n`构成的BST个数，其中跟结点`1 <= i <= n`。

显然，根据分析，我们可以得到，`G(n) = \sum_{i=1}^n F(i, n)`。

同样，对于`F(i, n)`，我们也可以化为由左右两个子序列构成的BST的乘积，即`F(i, n) = G(i - 1) * G(n - i)`。

注意，虽然右半部分是`i+1, i+2, ..., i+(n-i)`，但是尤其构成的BST与`1, 2, ..., n-1`是一样的，所以同样可以用`G(n - 1)`。

这样，结合以上两个式子，就能得到，`G(n) = \sum_{i=1}^n G(i - 1) * G(n - i)`。

另外，初始状态，`G[0] = G[1] = 1`。

走到这里，就发现，这其实是个DP了。

### 代码

```python
class Solution:
    def numTrees(self, n: int) -> int:
        G = [0] * (n + 1)
        G[0], G[1] = 1, 1
        for i in range(2, n + 1):
            for j in range(1, i + 1):
                G[i] += G[j - 1] * G[i - j]
        return G[n]
```

### 说明

同思路。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n^2) | O(n) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 30ms | 14.3MB |
| 排名 | 59.47% | 46.78% |

## 总结

借助BST作为背景的数学推导DP题，官方答案写得很好。
