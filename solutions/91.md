# 91. Decode Ways

| 题目 | 难度 |
| ---- | ---- |
| [91. Decode Ways](https://leetcode.com/problems/decode-ways/) | Medium |

## 题意

字母`A-Z`可以被以此编码为`1-26`。给一个`0-9`组成的字符串，返回原字母字符串共有多少种可能。

## 分析

当前位置可能是由消耗一个或两个位置的数字来的，有点像爬楼梯问题，一次爬一阶或者两阶。但这里解析是有条件的，所以在之前需要检查是否满足条件。

## 题解1

### 思路

DP。这题就需要记录之前每个位置的可能性了。定义`dp[i]`为字符串`s[:i]`共有多少种原始编码可能性，初始化都为`0`，除了`dp[0] = 1`。显然，对于位置`s[:i]`，有两种可能，要么是`s[:i - 1]`完成编码，然后`s[i - 1]`完成编码，或者是`s[:i - 2]`完成编码，然后`s[i - 2:i]`编码。第一种情况要求`s[i - 1] != '0'`，第二种情况要求`s[i - 2:i]`必须是`10-26`之间的数字（含）。两种可能性加起来就是当前位置的总可能性。

### 代码

```python
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        dp = [0] * (n + 1)
        dp[0] = 1
        for i in range(n):
            if s[i] != '0':
                dp[i + 1] += dp[i]
            if i > 0:
                if s[i - 1] == '1':
                    dp[i + 1] += dp[i - 1]
                elif s[i - 1] == '2' and s[i] in '0123456':
                    dp[i + 1] += dp[i - 1]
        return dp[-1]
```

### 说明

同思路。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(n) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 32ms | 14.2MB |
| 排名 | 79.53% | 67.22% |

## 总结

这题也是在官方DP集合里，跟[413](413.md)很像，但是这题不能一遍遍历直接解决了，这题需要老老实实DP。因为有之前413的经验，所以DP还是蛮好想的。
