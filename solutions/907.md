# 907. Sum of Subarray Minimums

| 题目 | 难度 |
| ---- | ---- |
| [907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/) | Medium |

## 题意

给一个数字列表，计算其中所有由连续的元素组成的子集中的最小值的和，返回其模`10 ^ 9 + 7`的值。

## 分析

有多种思考问题的方式，这里介绍一种时间复杂度较低的，见思路。

## 题解1

### 思路

对于每个数`arr[i]`，找到以`arr[i]`为最小值的由连续的元素组成的子集的个数，记为`count[i]`，然后计算`sum(arr[i] * count[i]), 0 <= i < len(arr)`即可。

如何确定`count[i]`呢？不难发现，只要找到最大的区间`[i_left, i_right]`，满足`arr[j] > arr[i], i_left <= j < i`且`arr[j] >= arr[i], i < j <= i_right`即可。此时，从左侧选取一个元素作为开始，从右侧选取一个元素作为结束，这样一共有`(i - i_left + 1) * (i_right - i + 1)`种组合方式，即为`count[i]`。

现在，问题的难点就转化为了，如何高效地寻找最大的区间`[i_left, i_right]`。显然，可以一步步向左或向右试探下一个值是否满足，但这样的速度确实太慢了，会超时。

实际上，`i_left`即从右往左数下一个比`i`位置的数字更小的数所在的位置，而`i_right`即左往右数下一个比`i`位置的数字更小或等于的数所在的位置。求下一个小于xxx的位置这种问题，借助单调栈，即可解决。

单调栈，即保证栈内元素是单调递增或单调递减的栈。例如，现在我们有一个列表`[1, 3, 4, 5, 2, 9, 6]`，将其压入单调栈（单调递增），过程依次为：

1. 压入`1`，栈为`[1]`
2. 压入`3`，栈为`[1, 3]`
3. 压入`4`，栈为`[1, 3, 4]`
4. 压入`5`，栈为`[1, 3, 4, 5]`
5. 尝试压入`2`，但压入栈后栈为`[1, 3, 4, 5, 2]`，不再单调，因此需要依次将栈内元素`5`、`4`、`3`出栈，此时再将`2`入栈，栈满足单调，为`[1, 2]`
6. 压入`9`，栈为`[1, 2, 9]`
7. 尝试压入`6`，但压入栈后栈为`[1, 2, 9, 6]`，不再单调，因此需要依次将栈内元素`9`出栈，此时再将`6`入栈，栈满足单调，为`[1, 2, 6]`

为了之后方便，可以在列表最后再加上一个小于列表中所有数字的值，例如此处添加`-1`在末尾，则最后还有一步尝试压入`-1`，即：

8. 尝试压入`-1`，但压入栈后栈为`[1, 2, 6, -1]`，不再单调，因此需要依次将栈内元素`6`、`2`、`1`出栈，此时再将`-1`入栈，栈满足单调，为`[-1]`

在这个过程中，我们可以很容易地求出**在其之后第一个小于其本身的位置**。每当遇到位置`i`的元素无法直接入栈，需要栈内元素位置`i - 1`、`i - 2`一直到`i - k`这`k`个元素出栈的时候，这`k`个元素即找到了在其之后第一个小于其本身的位置为`i`。最后压入的小于所有元素的`-1`过程中出栈的元素（位置）则表示找不到在其之后第一个小于其本身的位置。

在单调栈的额帮助下，寻找长度为`n`的列表的每个位置的下一个小于其本身的位置的问题，只需要`O(n)`时间即可完成，而蛮力法需要`O(n^2)`的时间完成。

理解单调栈之后，回头解决我们的问题。我们可以从左到右，再从右到左压一遍单调栈，这样就能找到每个位置`i`所对应的`i_left`与`i_right`。注意，两遍寻找的规则有一点小小的不同，有一边寻找在其之后第一个**小于**其本身的位置，另一边寻找在其之后第一个**小于等于**其本身的位置，这样则保证所有的区间都能覆盖上。

### 代码

```python
class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        n = len(arr)
        i_left_list = [0] * n
        i_right_list = [n - 1] * n
        stack = []
        for i in range(n):
            while stack and arr[stack[-1]] > arr[i]:
                i_right_list[stack.pop()] = i - 1
            stack.append(i)
        stack = []
        for i in range(n - 1, -1, -1):
            while stack and arr[stack[-1]] >= arr[i]:
                i_left_list[stack.pop()] = i + 1
            stack.append(i)
        result = 0
        for i in range(n):
            result = (result + arr[i] * (i - i_left_list[i] + 1) * (i_right_list[i] - i + 1)) % (10 ** 9 + 7)
        return result
```

### 说明

同思路。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(n) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 556ms | 18.4MB |
| 排名 | 60.39% | 73.95% |

## 总结

第一次深入了解单调栈，这题不用单调栈都没法通过OJ，时间卡得很死。
