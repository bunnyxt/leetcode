# 260. Single Number III

| 题目 | 难度 |
| ---- | ---- |
| [260. Single Number III](https://leetcode.com/problems/single-number-iii/) | Medium |

## 题意

给一串整数，其中有两个整数只出现了一次，另外其他的整数都出现了两次，问这两个整数是多少。要求线性时间常数空间。

## 分析

位运算。详见下面的思路。

## 题解1

### 思路

这题用到了三个位运算技巧，解释如下。

1. `x ^ x = 0`，相同两数字，这个很常见，不解释。
2. `x & (-x) = (0..010...0)_2`，**结果是一个`bitmap`，只有一个`1`，和`x`的最右侧的`1`的位置相同**。这个是补码的特性，整数补码取负数方法是**按位取反再加一**，全部取反之后直接`&`肯定都是`0`，再加`1`的话会发生进位，直到遇到取反后第一个是`0`的位置，这个位置承载了低一位进来的`1`，并且不会再往高处进位，因此这一位变成了`1`，又因为之前这一位也是`1`（取反后是`0`），所以`&`之后这一位是`1`。更高位因为没有变化，就是单独取反了，所以`&`之后更高位都是`0`，更低位原数就全是`0`，因为取反后更地位原先都是`1`（这一位是取反后第一个`0`），这样`&`之后更低位必然都是`0`。
3. `x ^ (0...010...0)_2`，第二个运算数字是一个`bitmap`，即只有一位是`1`，该式子**当且仅当`x`的该位置也是`1`时才为真**。

介绍完这三个技巧，就可以正式介绍我们的算法了。记唯二只出现了一次的数字为`x`和`y`。

1. 将所有数字做异或运算，最后结果必然是`two_xor = x ^ y`，因为其他数字都出现了两次，`a ^ a = 0`了。
2. 获取只包含`two_xor`的最右侧的`1`的`bitmap`，记为`diff = two_xor & (-two_xor)`，原理见上述技巧2。这个`diff`中为`1`的那一位（记为位`k`），是`x ^ y`结果中的一个`1`。为什么`x ^ y`在位`k`会是`1`呢？说明`x`和`y`在位`k`上的值不同，假设是`x`在位`k`上是`1`，那么`y`在位`k`上就是`0`，这是**区分`x`和`y`的重要依据**。
3. 将所有`num & diff`为真的`num`进行异或运算，最后结果就是`x`。显然，`num & diff`为真的`num`必然不包括`y`，因为`y`在位`k`上是`0`，剩下的只有`x`和成对的该位为`1`的数字了，成对的数字异或之后结果为`0`，只剩下一个单独的`x`了。
4. 有了`x`，有了`x ^ y`，那么`y = x ^ y ^ x`即可得到。

### 代码

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        two_xor = 0
        for num in nums:
            two_xor ^= num
        diff = two_xor & (-two_xor)
        x = 0
        for num in nums:
            if num & diff:
                x ^= num
        return [x, two_xor ^ x]
```

### 说明

同思路。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(1) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 60ms | 15.6MB |
| 排名 | 77.32% | 95.72% |

## 总结

位运算，不常考，就当见识一下。
