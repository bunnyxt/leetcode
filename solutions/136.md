# 136. Single Number

| 题目 | 难度 |
| ---- | ---- |
| [136. Single Number](https://leetcode.com/problems/single-number/) | Easy |

## 题意

现在有一个列表，其中每个数字都出现了两次，除了一个数字只出现了一次，求这个只出现的数字。要求：时间复杂度O(n)，空间复杂度O(1)。

## 分析

题意非常好懂，也能想到不少方法，但是看到O(n)时间O(1)空间着实犯了难。

这种时候，就该想想，非常规的，魔法了（bushi

## 题解1

### 思路

异或。

- x xor x == 0
- x xor 0 == x

那把整个列表中的数字全做一遍异或，出现两次的数字，两两配对，异或结果都是0，而唯一一个落单的，与0异或完之后，结果就是他本身了。

### 代码

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        result = 0
        for num in nums:
            result ^= num
        return result
```

### 说明

同思路。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(1) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 128ms | 16.7MB |
| 排名 | 84.37% | 19.88% |

## 总结

位运算，异或的魔法用法。怎么说呢，记着吧，靠自己凭空想出来，我现在还做不到，只能多积累了。
