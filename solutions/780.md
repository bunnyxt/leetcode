# 780. Reaching Points

| 题目 | 难度 |
| ---- | ---- |
| [780. Reaching Points](https://leetcode.com/problems/reaching-points/) | Hard |

## 题意

问`(sx, sy)`能不能通过`(x, x + y)`或者`(x + y, y)`一路叠加到`(tx, ty)`。

## 分析

题目给的`tx`和`ty`最大可以是`10 ^ 9`，特别大，普通DFS或者BFS这样是肯定会TLE的。需要找规律。

## 题解1

### 思路

逆向思考。考虑`(x, y)`是怎么来的，通过两数字之间的大小关系只有三种情况。

- `x == y`，因为`sx`和`sy`都至少是`1`，所以唯一可能性就是`(sx, sy)`就是`(x, y)`。
- `x > y`，那么`x`一定是通过`(x - y) + y`得到的。
- `x < y`，那么`y`一定是通过`(y - x) + x`得到的。

所以其实得到`(tx, ty)`的路径是唯一的，我们就可以这样一路反推回去，看能不能推到`(sx, sy)`。

### 代码

```python
class Solution:
    def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:
        while tx >= sx and ty >= sy:
            if tx == ty:
                break
            if tx > ty:
                if ty > sy:
                    tx %= ty
                else:
                    return (tx - sx) % ty == 0
            else:
                if tx > sx:
                    ty %= tx
                else:
                    return (ty - sy) % tx == 0
        return tx == sx and ty == sy
```

### 说明

整体结构统思路，但有一个优化的地方。

考虑`(x, y)`且`x > y`，很显然是通过`(x - y, y)`来的。如果此时`x - y > y`，那么上一步依旧是第一个数`- y`，即`(x - 2 * y, y)`。一路减下去，直到`x - k * y <-= y`才停。我们可以直接求出这个新的`x = x % y`。`x < y`时同理，`y = y % x`。

但是，有一个问题，就是考虑当前`(x, y) = (100000, 2)`，直接`x = x % y`就得到`(0, 2)`了，但是`x`、`y`都至少是`1`，此时需要检查目标点，如果`(sx, sy) = (1, 1)`这种情况，那么没关系，直接放过去就行了；如果`(sx, sy) = (2, 2)`，那就错过了，所以如果`y == sy`，直接检查`(x - tx) % y`，如果可以整除则说明可以通过叠加大量的`y`得到，那就可以达到，否则就会错过。

最后，判断`tx == sx and ty == sy`。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(log((max(tx, ty)))) | O(1) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 49ms | 13.9MB |
| 排名 | 58.61% | 83.76% |

## 总结

很有趣的题目。

最一开始肯定会想DFS或者BFS，但是数据范围太大了。

之后就要想从大到小检查，然后就会发现得到`(x, y)`的前置数字是固定的。

写好循环之后，发现还是TLE，就需要发现`(10000000, 1)`这种情况，就要想到用模除代替一个个慢慢减。

最后，最麻烦的是处理边界情况，如果小的那个数字等于目标数字了，另一边检查差值是否是小的那个数字的倍数即可。

一环套一环的思路递进很有趣，值得复习。
