# 134. Gas Station

| 题目 | 难度 |
| ---- | ---- |
| [134. Gas Station](https://leetcode.com/problems/gas-station/) | Medium |

## 题意

在一个环形路上有`N`个加油站，第`i`个加油站里的油量为`gas[i]`，你的车油箱无限大，一开始没有油，你需要花费`cost[i]`量的油从第`i`个加油站到下一个加油站，你的旅途可以从任何一个加油站开始，问从哪个加油站开始旅途可以绕环形路一圈回到原点，如果没有则返回`-1`，保证只有`0`或`1`个解，`gas`与`cost`数组长度相同，元素均非负。

## 分析

直接暴力DFS肯定是可以做，但重复计算太多，时间复杂度较高。实际上，某两个加油站之间的消耗（剩余/欠缺的油量）都是固定的，但DFS重复计算了很多遍。

## 题解1

### 思路

定理：如果从加油站A出发，到达不了加油站B（但可以到B-1，即B是第一个到不了的地方），那么从介于A与B之间的任意一个加油站出发，均到达不了B。

证明：从A出发往B走，B是第一个到不了的加油站，那么对于A到B之间经过的任意一个加油站C，从A出发往B走到达C的时候油箱是有油的，记为`k`且`k >= 0`，此时再从C出发到不了B。为了从C到达B，就需要此时的C点有更多的油，即`k' > k`，推导易得`k' > 0`。如果从C出发的话在，在C的时候初始状态是没油的，`k' = 0`不满足`k' > 0`的要求，故肯定也到达不了B。只有尝试从`A`的上一个加油站A-1出发，尝试积累更多的初始油量，才有可使得到达C点时的油量`k' > k`，才有可能到达C点，进而实现环形。

### 代码

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        start = len(gas) - 1
        end = 0
        tank = gas[start] - cost[start]
        while start > end:
            if tank >= 0:
                tank += gas[end] - cost[end]
                end += 1
            else:
                start -= 1
                tank += gas[start] - cost[start]
        return start if tank >= 0 else -1
```

### 说明

一开始假设从`len(gas) - 1`（即最后一个加油站）出发，前往第`0`个加油站，此时`tank`里有`gas[start] - cost[start]`的油。主循环当`start > end`即还未成环时进行，检测此时`tank`剩余油量，如果剩余油量`tank >= 0`，则说明可以从`start`到`end`，那么尝试再向前走一步，走到`end + 1`，更新`tank += gas[end] - cost[end]`；如果`tank < 0`，油不够（欠着了），那么说明从`start`走不到`end`，更不用说`start`经过`end`再绕回`start`了。根据之前证明定理，`start`与`end`之间任意站点都无法作为起点走到`end`进而实现环形，只能尝试`start - 1`从上一个点出发，积累更多的初始油量，才有可能到达`end`点。

`while`循环结束后，环形达成，如果`tank`里还剩余有油或刚好用完，则说明从当前的`start`是可以完成环形的，返回`start`即可，否则说明无法成环，返回`-1`。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(1) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 48ms | 14.8MB |
| 排名 | 95.25% | 59.71% |

## 总结

这题一眼就能看出来有很多重复计算，但到底怎么利用之前的计算想了很久还是没想出来，最后发现根本都不涉及到动态规划的问题，就是得自己看出来那个定理，还有选择`start`和`end`的初始位置，这样的话一趟遍历就完事了，这题有点走一步看一步观察的感觉。
