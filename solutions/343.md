# 343. Integer Break

| 题目 | 难度 |
| ---- | ---- |
| [343. Integer Break](https://leetcode.com/problems/integer-break/) | Medium |

## 题意

给正整数`2 <= n <= 58`，将其分成多个（不止一个）整数的和，问这些分出的整数的积最大是多少。

## 分析

## 题解1

### 思路

动态规划。`dp[i]`表示`i`分割后最大的乘积。如果只考虑分成两个数的话，那么其实就有`1 * (i - 1)`、`2 * (i - 2)`...等等若干种分发，我们可以依次获得这些分发的乘积。注意，分解成的两个数都有两种选择，要么直接乘以本身不继续分了，要么继续分成若干个数然后算乘积，我们直接选取这两种情况中较大者即可。

### 代码

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [1] * (n + 1)
        for i in range(3, n + 1):
            a, b = 1, i - 1
            while a <= b:
                dp[i] = max(dp[i], max(a, dp[a]) * max(b, dp[b]))
                a, b = a + 1, b - 1
        return dp[n]
```

### 说明

同思路，代码应该是比较好看懂的。这里需要注意边缘情况，`dp[1] = dp[2] = 1`， botton-up dp从3开始循环。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n ^ 2) | O(n) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 57ms | 14MB |
| 排名 | 18.49% | 98.28% |

## 总结

这题是放在DP题集里遇到的。这个DP算法有点像找零问题，直接简化为一次把数分成两个数，然后`max(a, dp[a])`这里决定是否继续往下分，这个设计是关键。

// TODO 数学解法
