# 204. Count Primes

| 题目 | 难度 |
| ---- | ---- |
| [204. Count Primes](https://leetcode.com/problems/count-primes/) | Easy |

## 题意

给一个整数`n`，返回小于`n`的素数（只考虑正数）的个数。注意，`0 <= n <= 5 * 10^6`，`0`与`1`不算素数。

## 分析

最简单的方法是，依次从`0`到`n - 1`检查数字是否为素数，一个简单的检查素数的函数如下：

```python
def isPrime(i):
    flag = True
    for j in range(2, math.floor(math.sqrt(i)) + 1):
        if i % j == 0:
            flag = False
            break
    return flag
```

但显然，这样复杂度是`O(n^2)`，必然超时。

这时候，需要倒过来想，其实`n`是有大小上限的，所以可以从小到大以此标记出所有的素数，再统计共有多少个即可。

## 题解1

### 思路

顺着分析往下走，其实标记素数是比较困难的，但是标记非素数（`0`以及合数）是很简单的，因为合数必然存在除了`1`和自身以外的质因数。所以，我们可以从最小的素数`2`开始，标记所有`2`的倍数，必定是合数。然后再前进到下一个素数`3`、`5`等等等等。最大不超过`n`即可。这样就能依次标记完所有的合数。

但是，这个方法标记存在重复标记，可以参考代码和说明，那里去掉了重复标记，这样效率会更高。

### 代码

```python
class Solution:
    def countPrimes(self, n: int) -> int:
        if n < 3:
            return 0
        isPrimeBuckets = [1] * n
        isPrimeBuckets[0] = isPrimeBuckets[1] = 0
        for i in range(2, int(n ** 0.5) + 1):
            if isPrimeBuckets[i]:
                isPrimeBuckets[i * i :n:i] = [0] * len(isPrimeBuckets[i * i:n:i])
        return sum(isPrimeBuckets)
```

### 说明

`n < 3`时，必然为`0`，直接返回。

`isPrimeBuckets`列表长度为`n`，存储`0`到`n-1`（含）这些数是否为素数，不是素数的话标记为`0`，是素数的话标记为`1`，初始时默认都是`1`。显然，`isPrimeBuckets[0]`与`isPrimeBuckets[1]`应该为`0`。

之后的循环，从`2`开始，到`int(n ** 0.5)`（含）结束。如果当前`i`为素数，即`isPrimeBuckets[i]`是`1`，则将`2`的倍数的位置全部设置为`0`，即`isPrimeBuckets[i * i :n:i] = [0] * len(isPrimeBuckets[i * i:n:i])`，这是Python的独有的写法，等效于
```python
for j in range(i * i, n, i):
    isPrimeBuckets[j] = 0
```
且比单纯循环效率会高一些，因此这样写。

注意，这里为什么外层循环到`int(n ** 0.5)`（含）而不是到`n`（不含）结束？为什么内层赋值从`i * i`而不是`i * 2`开始？

第二个问题比较好回答，很显然，例如`i = 5`时，`5 * 2`必然已经在`i = 2`那趟被标记过为合数，同理，`5 * 3`必然已经在`i = 3`那趟被标记过为合数，`5 * 4`本身因为`4`是合数，所以在`4`被标记为合数的那一趟（即`i = 2`时）也被标记过为合数了，第一个不是合数的应该是`5 * 5`，即`i * i`，而不是`i * 2`。

第二个问题回答完之后，第一个问题也就好回答了。当`i > int(n ** 0.5) + 1`时，`i * i > n`，即必然不可能得出更多的小于`n`的合数了，所以超过这个上限的数值`i`就没有比较进入内循环了。

最终，`sum(isPrimeBuckets)`即`1`的个数，即被标记为素数的个数，就是题目所要求的。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(n) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 656ms | 91.8MB |
| 排名 | 94.99% | 40.04% |

## 总结

这个题的递进思路就很清晰，首先是最暴力的依次检查，判断素数的`isPrime(i)`也写了一遍加以练习，但这样显然会超时。之后想到标记素数，从`2`开始标记到`n`，这样的话复杂度是满足了，但还可以继续优化，那就是循环的范围，只要到`int(n ** 0.5)`（含）结束，内部标记合数从`i * i`开始即可。

这题其实需要手动在草稿纸上写一写，就能发现规律了。
