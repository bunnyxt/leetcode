# 330. Patching Array

| 题目 | 难度 |
| ---- | ---- |
| [330. Patching Array](https://leetcode.com/problems/patching-array/) | Hard |

## 题意

给一个从小到大排序的正整数数组`nums`和一个整数`n`，问最少需要向`nums`中添加几个数，就可以使得可以使用`nums`的子集的和构成`1, 2, ..., n`所有的数。

例如，`nums = [1, 3]`，`n = 6`，`nums`的子集只有`[1], [3], [1, 3]`，其子集和只能构成整数`1, 3, 4`，不够`1, 2, ..., 6`。但我们只需要添加元素`2`进入`nums`，使得`nums = [1, 2, 3]`，此时`nums`的子集有`[1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]`，其和分别是`1, 2, 3, 3, 4, 5, 6`，满足`1, 2, ..., 6`。因此，只需要添加`1`个元素即可满足条件，算法返回`1`。

## 分析

我们可以在纸上先写几个例子看看，到底需要添加什么数字。

以`nums = [1, 5, 10]`，`n = 20`为例。记当前已有的所有数字集合为`A0 = { a1, a2, ..., ak }`。我们可以把`[1, 20]`中当前已有的数字写出来，没有的数字空出来，如下：

```
 1,  _,  _,  _,  5, 
 6,  _,  _,  _, 10,
11, __, __, __, 15,
16, __, __, __, __.
```

显然，如果我们在`nums`中添加一个数字`m`，那么当前已有的数字集合会变为`A1 = { a1, a2, ..., ak, a1+m, a2+m, ..., ak+m, m }`（除去重复的数字和不在`[1, n]`中的数字）。

那么这个`m`应该取多少好呢？很容易发现，`A0`中最小的缺失的位置`miss = 2`，是一个很合适的选择。可以看到，如果不加`2`，那么集合`A1, A2, ...`中的`2`就必定是空着的。为了填补当前状态下最小的空缺位置，必须要添加该数字。因此。第一个需要添加的数字为`2`。

添加完`2`后，根据上面的方法计算`A1`，图示如下：

```
 1,  2,  3,  _,  5, 
 6,  7,  8,  _, 10,
11, 12, 13, __, 15,
16, 17, 18, __, __.
```

此时`miss = 4`。同理，选择`4`添加进`nums`，计算得到`A2`，图示如下：

```
 1,  2,  3,  4,  5, 
 6,  7,  8,  9, 10,
11, 12, 13, 14, 15,
16, 17, 18, 19, 20.
```

此时最小位置`miss = 21 > n = 20`，也就是说`[1, n]`中所有数字都全了，退出循环，返回添加的数字的个数（此例中为`2`）。

## 题解1

### 思路

手工分析的思路是解决问题的基础。实际上，按照分析的步骤，构建算法，也可以得到一个解答，但会爆时间空间，因此需要改进/优化。

令`miss`为`[0, n]`中最小的缺失的值。这意味着，此时我们已经可以使用`nums`的子集和构建`[0, miss)`中所有的值了。此时如果`nums`中存在一个`num <= miss`，那么我们就可以将此`num`添加到`[0, miss)`中，以此构建`[0, miss+num)`中的所有值。如果这样的`num`不存在，那我们必须要在`nums`中添加一个`num <= miss`，显然，我们希望尽可能快得扩充我们能表示得所有数值，所以我们需要添加一个尽可能大的`num`，此时`miss`就是一个最佳的选择，可表示的数字范围扩充到`[0, miss+miss)`。

ref: [Solution + explanation](https://leetcode.com/problems/patching-array/discuss/78488/Solution-%2B-explanation)

### 代码

```python
class Solution:
    def minPatches(self, nums: List[int], n: int) -> int:
        miss = 1
        added = 0
        i = 0
        while miss <= n:
            if i < len(nums) and nums[i] <= miss:
                miss += nums[i]
                i += 1
            else:
                miss += miss
                added += 1
        return added
```

### 说明

`miss`是当前缺失的最小的值，初始化为`1`。

`added`是记录添加了多少个元素的变量，初始化为`0`。

`i`是`nums`数组的指针，初始化指向`nums`数组第一个元素，即`0`。

循环开始，当`miss > n`的时候结束循环。首先检查`i`是否还指向`nums`数组内的有效位置，如果是的话，检查指向的元素`nums[i]`是否`<= miss`，如果是的话，进入分析的第一种情况，我们可以将可以表示的数字范围扩充到`[1, nums[i]+miss)`，并且指针向后移动一位。否则的话，进入分析的第二种情况，需要添加`miss`元素进`nums`，可表示的数字范围扩充到`[0, miss+miss)`。

这个指针每次添加尽可能多的大小元素来扩充表示范围的思路应该算是**贪心**算法。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(1) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 52ms | 14.4MB |
| 排名 | 95.24% | 9.52% |

## 总结

很遗憾，自己在纸上写了半天，也没最终推导出题解1的关键思路。实际上的精髓是：去除不必要的内部充分计算，提取问题本质。解法中使用指针遍历数组（贪心）的方式实在是太棒了。
