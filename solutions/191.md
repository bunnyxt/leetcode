# 191. Number of 1 Bits

| 题目 | 难度 |
| ---- | ---- |
| [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/) | Easy |

## 题意

问一个整数的二进制表示形式中的`1`的个数。

## 分析

位运算。

## 题解1

### 思路

用`x & 1 == 1`判断最后一位是否为`1`，`x >>= 1`向右移动一位进入下一轮判断。

### 代码

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        count = 0
        while n:
            if n & 1:
                count += 1
            n >>= 1
        return count
```

### 说明

同思路，循环体内每次比较当前最右一位是否为`1`，然后往右移一位，直到`n`中不存在`1`为止（此时`n == 0`）。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(1) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 28ms | 14.4MB |
| 排名 | 89.44% | 5.77% |

## 题解2

### 思路

利用技巧`x &= (x - 1)`，这个操作会将`x`二进制数值中最右侧的`1`设置为`0`。`x - 1`的二进制表示中，原先`x`的二进制表示的末尾的`0`，因为不够减，会向高位借位，结果会变成`1`，直到遇到最右侧的`1`，该位借给低位`1`之后自身变成`0`，不会再向更高位借位。此时，`x & (x - 1)`，上述提到的最右侧这些位都存在`0`，所以结果这些位（主要是最右侧的`1`）都清零了。这样，能进行几次`x &= (x - 1)`操作，就表示能有几个`1`。

### 代码

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        count = 0
        while n:
            count += 1
            n &= (n - 1)
        return count
```

### 说明

同思路。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(1) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 20ms | 14.4MB |
| 排名 | 99.49% | 5.77% |

## 总结

虽然本来就是个很简单的题目，但还是能用`x &= (x - 1)`技巧继续优化，学习了。
