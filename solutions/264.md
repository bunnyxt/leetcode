# 264. Ugly Number II

| 题目 | 难度 |
| ---- | ---- |
| [264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/) | Medium |

## 题意

一个数字是丑数，如果其质因数只由`2 3 5`组成。显然，`1`是最小的（第一个）丑数。返回第`n`个丑数。

## 分析

分析得到，一个丑数肯定是由一个已知的丑数，乘上`2 3 5`构成的。因此，需要一种方法记录下，从第一个丑数开始的已经认定为丑数的数字。

一个很基本的想法是，从`2`开始往下数，判断数字是否能被`2 3 5`整出，且整除后的数字也是个丑数（在某个集合中存储）。实际实现上时间复杂度较高。

## 题解1

### 思路

动态规划。一维长度为`n`的数组存储前`n`个丑数，显然`dp[0] = 1`。前面已经说过了，一个新的丑数必然是一个已经存在的丑数的`2 3 5`倍，那么我们用三个变量指向那个已经存在的丑数（位置指针，初始化为`0`），每次找这三个位置的丑数乘以`2 3 5`中最小的数字作为下一个丑数，之后更新指针即可。注意，如果该数字可以由多种方式获得，那么对应的所有方式的指针都要往后移动。

### 代码

```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        p2 = p3 = p5 = 0
        ugly_numbers = [0] * n
        ugly_numbers[0] = 1
        for i in range(1, n):
            ugly_numbers[i] = min(ugly_numbers[p2] * 2, ugly_numbers[p3] * 3, ugly_numbers[p5] * 5)
            if ugly_numbers[i] == ugly_numbers[p2] * 2:
                p2 += 1
            if ugly_numbers[i] == ugly_numbers[p3] * 3:
                p3 += 1
            if ugly_numbers[i] == ugly_numbers[p5] * 5:
                p5 += 1
        return ugly_numbers[n - 1]
```

### 说明

同思路。思路可能说得不是很清楚，代码感觉更清楚一些。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(n) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 144ms | 14.4MB |
| 排名 | 81.51% | 20.87% |

## 总结

动态规划，存放指针指向对应的丑数，跟一般的动态规划不太一样，存的是位置，更新的是位置，不是最优值。
