# 44. Wildcard Matching

| 题目 | 难度 |
| ---- | ---- |
| [44. Wildcard Matching](https://leetcode.com/problems/wildcard-matching/) | Hard |

## 题意

匹配字符串，`pattern`中包括`?`和`*`通配符。

## 分析

回溯法，因为`*`可能匹配`0`到任意多个，所以要检查所有的`*`匹配的个数的可能性。

## 题解1

### 思路

同分析，遇到`*`的时候，可以选择`s`往下移动若干个，然后再移动`p`跳过`*`。

### 代码

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        ls, lp = len(s), len(p)
        failed = set()
        
        def check(ps, pp):
            # already checked
            if (ps, pp) in failed:
                return False
            # already matched
            if ps == ls and pp == lp:
                return True
            # no string left, but still have pattern
            if ps == ls:
                # if left pattern is *, go on
                if p[pp] == '*':
                    if check(ps, pp + 1):
                        return True
                failed.add((ps, pp))
                return False
            # no pattern left, but still have string
            if pp == lp:
                failed.add((ps, pp))
                return False
            # pattern is ?, ps and pp move on together
            if p[pp] == '?':
                if check(ps + 1, pp + 1):
                    return True
                failed.add((ps, pp))
                return False
            # pattern is *, ps and pp move on together or just move on ps or pp
            if p[pp] == '*':
                if check(ps + 1, pp) or check(ps, pp + 1) or check(ps + 1, pp + 1):
                    return True
                failed.add((ps, pp))
                return False
            # just check euqality of string and pattern, then ps and pp move on together
            if s[ps] == p[pp] and check(ps + 1, pp + 1):
                return True
            failed.add((ps, pp))
            return False
            
        return check(0, 0)
```

### 说明

同思路，DFS回溯函数在匹配到最后字符串和匹配模板都匹配完了的时候才返回`True`，否则检查看当前是否能匹配上，如果可以就DFS往下走（`ps`或`pp`往下递增），否则返回`False`。

`failed`集合存储所有检查过的没法继续的位置，这样保证同一个位置不会检查多次。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n ^ 2) | O(n) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 864ms | 130.8MB |
| 排名 | 52.19% | 15.19% |

## 总结

带记忆化的回溯法是最直接的思路，不过需要考虑周全边界情况。
