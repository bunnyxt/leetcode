# 387. First Unique Character in a String

| 题目 | 难度 |
| ---- | ---- |
| [387. First Unique Character in a String](https://leetcode.com/problems/first-unique-character-in-a-string/) | Easy |

## 题意

给一个字符串，返回该字符串中第一个（下标最小的）没有重复的字符（在整个字符串中只出现了一次的字符）的下标。如果没有这样的字符，那么输出`-1`。输入的字符串只包含26个小写字母。

## 分析

为了确保某一个字符只出现了一次，必然需要遍历完整个字符串，在遍历的过程中做一些记录，遍历完之后对记录的内容进行一些处理，最终得到目标。

## 题解1

### 思路

同分析，两次循环，第一次记录每个字符出现的次数，第二次循环找到最小的只出现一次的字符的坐标。

### 代码

```python
from collections import defaultdict

class Solution:
    def firstUniqChar(self, s: str) -> int:
        if not s:
            return -1
        
        d = defaultdict(int)
        for c in s:
            d[c] += 1
            
        if min(d.values()) > 1:
            return -1
        
        for i, c in enumerate(s):
            if d[c] == 1:
                return i
        
        # return -1
```

### 说明

使用字典`d`存储字符串`s`中每个字符出现的次数。

这里有一个挺有效的优化。如果字符串中并不存在只出现了一次的字符，那么第二个循环必须完整跑完才能确定。然而，其实我们也可以直接在第二次循环之前通过检查字典`d`中是否存在`value`为1的字符，如果没有的话就不用走第二次循环了，直接返回`-1`。显然，字符串可以很长，但字符数最多只有`26`个，因此此优化在字符串很长的时候优化效果会很明显，测试程序运行时间从`124ms`降低到了`88ms`。

这里使用字典来存储，但实际上可以直接手动`ord(x)-97`来计算哈希，我个人这样做的结果反而运行时间更长了，因此最后也没这样做。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(1) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 88ms | 14.4MB |
| 排名 | 87.03% | 16.86% |

## 总结

一个简单的题，可以认为有考手动哈希，或者考优化。
