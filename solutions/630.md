# 630. Course Schedule III

| 题目 | 难度 |
| ---- | ---- |
| [630. Course Schedule III](https://leetcode.com/problems/course-schedule-iii/) | Hard |

## 题意

有一系列课程，给出每门课上课所需时间，以及最晚需要在什么时间结束，同一时刻只能上一门课，一门课开始上了就必须连续上完，问最多能上多少课。

## 分析

首先，很容易得出一个贪心结论：优先上结束时间早的课。如果结束时间相同，则优先上耗时少的课。

然而，困难在于，可能结束时间早的课耗时很多，稍晚时间结束的课耗时较少，那么就可以放弃前者，多上点稍晚时间结束的课。

那么，按照结束时间从早到晚依次考虑课程，其实我们需要一种**撤回**的办法，当后来发现能上更多的课的时候，撤回之前的计划。

## 题解1

### 思路

首先，同分析，优先上结束时间早的课，因此按照结束时间从早到晚排序课程。遍历，选择上此课，如果此时耗时超过当前课程的时间限制，则退掉已经上的课中耗时最长的（可能是自己），这样即可保证当前课程在规定时间内上完。

### 代码

```python
import heapq

class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        heap = []
        start = 0
        for t, end in sorted(courses, key=lambda x: x[1]):
            start += t
            heapq.heappush(heap, -t)
            if start > end:
                start += heapq.heappop(heap)
        return len(heap)
```

### 说明

每次循环结束之后都能保证，当前上的所有课的结束时间不会超过当前课程的结束时间。使用堆来快速获取上过的课中最耗时的课程所耗的时间。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n * logn) | O(n) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 763ms | 20.2MB |
| 排名 | 82.84% | 29.29% |

## 总结

非常巧妙的贪心题。遍历，先往前走，然后找可以撤回的课程（通过堆来快速获取），这个思路很像[1642](1642.md)，值得学习。
