# 27. Remove Element

| 题目 | 难度 |
| ---- | ---- |
| [27. Remove Element](https://leetcode.com/problems/remove-element/) | Easy |

## 题意

给一个数组`nums`和一个数字`val`，直接在`nums`数组上操作，去除`nums`中与`val`相等的元素，返回新的数组的长度。数组内其他元素顺序可变，并且原数组内超过新数组长度的部分会被忽略。

## 分析

只需要一遍遍历肯定能找到所有不为`val`的值，时间复杂度显然是O(n)，空间复杂度要求O(1)，只能对数组本身做改动。

## 题解1

### 思路

双指针。快指针遍历数组，若当前元素不等于`val`，则赋值给慢指针指向的数组中的位置，慢指针向前移动；若当前元素等于`val`，则不进行赋值，慢指针不移动。

### 代码

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        curr = 0
        for i in range(len(nums)):
            if nums[i] != val:
                nums[curr] = nums[i]
                curr += 1
        return curr
```

### 说明

`curr`是慢指针，`i`是遍历数组用的快指针。遍历完成后，`curr`的数值即为新数组的长度，直接返回即可。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(1) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 24ms | 13.8MB |
| 排名 | 98.66% | 64.65% |

## 题解2

### 思路

双指针，首尾指针，首指针以此向后遍历，检查当前位置元素是否等于`val`，一旦等于`val`，则将尾指针位置的值复制给首指针当前位置元素，否则尾指针向前移动，直到首尾指针汇合停止。

### 代码

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        head, rear = 0, len(nums) - 1
        while head <= rear:
            if nums[head] == val:
                nums[head] = nums[rear]
                rear -= 1
            else:
                head += 1
        return rear + 1
```

### 说明

这个解法充分利用了题意中“数组内其他元素顺序可变”这一条件，发现值等于`val`时交换前后元素（或只做一次赋值，将尾指针指向的元素赋值给首指针指向的元素，这样减少两次赋值，更快），尾指针最终停下的位置即为新数组的最后一个元素的坐标。

此方法在数组`num`中`val`个数较少时，相对解法1来说，效率更高。解法1是在遍历到不等于`val`值时进行赋值操作，而解法2恰恰相反，在等于`val`时赋值。实际场景下，确实`val`个数较少的情况比较多见，因此可以认为某种程度上这是一个更优的解法。

### 评估

| 时间复杂度 | 空间复杂度 |
| ---- | ---- |
| O(n) | O(1) |

| | 运行时间 | 内存占用 |
| ---- | ---- | ---- |
| 数值 | 24ms | 13.8MB |
| 排名 | 98.66% | 51.37% |

## 总结

作为Easy题，没有太多比较难的算法，但是思路上有值得借鉴的地方。题解1很容易想到，很符合直觉思路；题解2的另一种双指针解法是建立在题目允许的改变元素顺序的情况下才成立的。不妨反过来想，如果解法没有用到题目中给出的所有信息，很可能这个没用到的信息能启发想到更有的解法。