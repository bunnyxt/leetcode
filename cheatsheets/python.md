# Python刷题Cheat Sheet

> Work In Progress
>
> 不定期更新

收录一些使用`Python`刷算法题时经常遇到的实用技巧。

为保证简洁，本Cheat Sheet没有包含太多细节，如存在模糊或与规范文档有出入，请以文档为准。欢迎贡献指正。

## 数值

整除：`a // b`，等价于`math.floor(a / b)`，返回最大的不超过`a / b`的整数

带余数除：`quotient, remainder = divmod(a, b)`

获取比其他数都大的值：`math.inf`，是`float`类型

获取比其他数都小的值：`-math.inf`，是`float`类型

求平方根：`math.sqrt(x)`

向上取整：`math.ceil(x)`，返回最小的不低于`x`的整数，即向正无穷取整

向下取整：`math.floor(x)`，返回最大的不超过`x`的整数，即向负无穷取整

四舍五入取整：`round(x)`

## 切片

`[start : stop : steps]`，可用在字符串、列表、元组上，“左闭右开”

注意：
- 三个位置的值必须都是整数，`steps`不可为`0`
- 如果`steps`为正数，则`start`和`stop`的缺省值分别是开始和结束位置；如果是负数则相反

## 字符串

字符串翻转：`s[::-1]`

字符串拼接：`s1 + s2`，注意这个操作的时间复杂度为`O(len(s1) + len(s2))`，如果有大量字符串需要拼接，考虑使用`join`（见下）

基于分隔符`x`分割成列表：`s.split(x)`，注意如果有多个`x`相邻出现，则会出现分割出空字符串的情况（例如`'xxx'.split('x')`得到`['', '', '', '']`）

使用`x`作为连接符将列表`l`中的字符串拼接成一个字符串：`x.join(l)`，`x`可以是空字符串`''`，列表`l`中所有元素必须都是字符串

获得Unicode码中值为`n`的字符：`chr(n)`，`chr(48) == '0'`，`chr(65) == 'A'`，`chr(97) == 'a'`

获得字符`x`在Unicode码中的值：`ord(x)`，`ord('0') == 48`，`ord('A') == 65`，`ord('a') == 97`

## 列表

列表翻转：`l[::-1]`

列表拷贝：`l.copy()`，或`l[:]`，或`l + []`，注意都是浅拷贝

列表拼接：`l1 + l2`，返回一个全新的列表

列表推导式：例如`[i * i for i in range(n)]`构建列表`[0, 1, 4, 9, 16, ..., (n - 1) * (n - 1)]`

构建长度为`n`，初始化值为`x`的一维列表：`[x] * n`，注意`x`必须是不可变类型，否则修改其中一个元素会影响到其他元素；如果`x`为可变类型（列表、字典、集合等），需要用列表推导式`[x for _ in range(n)]`

构建`m`行`n`列，初始化值为`x`的二维列表（矩阵）：`[[x] * n for _ in range(m)]`，同上`x`必须是不可变类型，否则内层也要嵌套一个列表推导式

在列表`l`中找元素`x`的下标：`l.index(x)`，返回`x`第一次出现的坐标，如果`x`不在`l`中会报错

作为栈使用：压栈用`l.append(x)`，出栈用`l.pop()`，获取栈顶元素用`l[-1]`，均在列表末尾操作，时间复杂度均为`O(1)`

## 元组

不可变类型，可哈希，因此可以作为字典的键，或者集合的元素。

## 字典

字典推导式：例如`{key: val for key, val in [(1, 'a'), (2, 'b')]}`构建字典`{1: 'a', 2: 'b'}`

遍历字典：`for key, val in d.items():`

// TODO defaultdict

## 集合

列表去重：`list(set(l))`

取交集：`s1 & s2`

取并集：`s1 | s2`

取差集：`s1 - s2`

## 双向队列

// TODO deque

## 堆

// TODO heap

## 循环

从`0`到`n - 1`：`for i in range(n):`

从`n - 1`到`0`：`for i in range(n - 1, -1, -1):`，或者直接翻转`for i in reversed(range(n)):`

## 排序

// TODO .sort()

// TODO reversed()

// TODO key

## 函数工具

// TODO lru_cache
